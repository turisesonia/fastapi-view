import json
import typing as t
from pathlib import Path
from urllib.parse import urljoin

from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from pydantic import computed_field, field_validator, model_validator
from pydantic_settings import BaseSettings, SettingsConfigDict


class ViteConfig(BaseSettings):
    # development or production mode.
    dev_mode: bool = False

    # Vite dev server protocol (http / https)
    dev_server_protocol: str = "http"

    # Vite dev server hostname.
    dev_server_host: str = "localhost"

    # Vite dev server port.
    dev_server_port: int = 5173

    # Vite dev server path to hot module replacement.
    ws_client_path: str = "@vite/client"

    # Path to vite compiled assets (only used in production mode).
    dist_path: Path = "dist"

    # URI to vite compiled assets (only used in production mode).
    dist_uri_prefix: t.Optional[str] = None

    # Vite static asset url
    static_url: t.Optional[str] = None

    # Path to your manifest file generated by Vite.
    manifest_path: Path = "dist/manifest.json"

    @computed_field
    @property
    def dev_server_url(self) -> str:
        return "{protocol}://{server_host}:{server_port}".format(
            protocol=self.dev_server_protocol,
            server_host=self.dev_server_host,
            server_port=self.dev_server_port,
        )

    @computed_field
    @property
    def dev_websocket_url(self) -> str:
        return "{dev_server_url}/{ws_client_path}".format(
            dev_server_url=self.dev_server_url,
            ws_client_path=self.ws_client_path,
        )

    @model_validator(mode="after")
    def check_dev_mode(cls, values: "ViteConfig"):
        dev_mode = values.dev_mode

        if not dev_mode:
            if not values.static_url and not values.dist_uri_prefix:
                raise ValueError(
                    "static_url or dist_uri_prefix must be set in production mode"
                )

        return values

    @field_validator("dist_uri_prefix")
    @classmethod
    def dist_uri_prefix_validator(cls, val: str):
        if isinstance(val, str) and len(val) <= 0:
            raise ValueError("dist_uri_prefix must be a non-empty string")

        return val

    model_config = SettingsConfigDict(
        extra="ignore",
        case_sensitive=False,
        env_file=".env",
        env_file_encoding="utf-8",
        env_prefix="VITE_",
    )


class Vite:
    _manifest: dict = None

    def __init__(self, app: FastAPI, templates: Jinja2Templates):
        self.conf = ViteConfig()

        templates.env.globals["vite_hmr_client"] = self.vite_hmr_client
        templates.env.globals["vite_asset"] = self.vite_asset

        self._setup(app)

    def _setup(self, app: FastAPI):
        if not self.conf.dev_mode and not self.conf.static_url:
            route = self.conf.dist_uri_prefix
            if not route.startswith("/"):
                route = f"/{route}"

            app.mount(route, app=StaticFiles(directory=self.conf.dist_path))

    def vite_hmr_client(self) -> str:
        if not self.conf.dev_mode:
            # production mode do not return HMR client.
            return ""

        return self._script_tag(
            src=self.conf.dev_websocket_url,
            attrs={"type": "module"},
        )

    def vite_asset(self, asset_path: str):
        while asset_path.startswith("/"):
            asset_path = asset_path[1:]

        if self.conf.dev_mode:
            return self._script_tag(
                src=f"{self.conf.dev_server_url}/{asset_path}",
                attrs={"type": "module"},
            )

        self._load_manifest()

        if asset_path not in self._manifest:
            raise FileNotFoundError(f"Asset not found: {asset_path}")

        asset_tags = [tag for tag in self._css_assets_handle(asset_path, [])]

        file = self._manifest[asset_path]["file"]

        asset_tags.append(
            self._script_tag(
                src=self._get_production_url(file), attrs={"type": "module"}
            )
        )

        return "\n".join(asset_tags)

    def _load_manifest(self):
        if self._manifest is None:
            with open(self.conf.manifest_path) as f:
                self._manifest = json.load(f)

    def _css_assets_handle(self, asset_path: str, processed: list[str]):
        stylesheet_tags = []

        entrypoint = self._manifest[asset_path]

        for import_ in entrypoint.get("imports", []):
            stylesheet_tags.extend(self._css_assets_handle(import_, processed))

        for css_path in entrypoint.get("css", []):
            if css_path not in processed:
                stylesheet_tags.append(self._link_tag(css_path))

                processed.append(css_path)

        yield from stylesheet_tags

    def _script_tag(self, src: str, attrs: dict = None) -> str:
        attrs_str = (
            "".join(
                f' {key}="{value}"' if value is not None else f" {key}"
                for key, value in attrs.items()
            )
            if isinstance(attrs, dict)
            else ""
        )

        return f'<script src="{src}"{attrs_str}></script>'

    def _link_tag(self, file: str) -> str:
        while file.startswith("/"):
            file = file[1:]

        href = self._get_production_url(file)

        return f'<link rel="stylesheet" href="{href}" />'

    def _get_production_url(self, file: str) -> str:
        prefix = (
            self.conf.static_url if self.conf.static_url else self.conf.dist_uri_prefix
        )

        if not prefix.endswith("/"):
            prefix += "/"

        return urljoin(prefix, file)
